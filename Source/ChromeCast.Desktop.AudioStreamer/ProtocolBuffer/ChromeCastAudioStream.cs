// Generated by protoc-gen-cs, Version=2.4.1.555, Culture=neutral, PublicKeyToken=17b3b1f090c3ea48.  DO NOT EDIT!
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using protB = global::Google.ProtocolBuffers;
using protBC = global::Google.ProtocolBuffers.Collections;
using protBD = global::Google.ProtocolBuffers.Descriptors;
using collG = global::System.Collections.Generic;
namespace ChromeCast.Desktop.AudioStreamer.ProtocolBuffer {
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
  public static partial class ChromeCastAudioStream {
  
    #region Extension registration
    public static void RegisterAllExtensions(protB::ExtensionRegistry registry) {
    }
    #endregion
    #region Static variables
    #endregion
    #region Extensions
    internal static readonly object Descriptor;
    static ChromeCastAudioStream() {
      Descriptor = null;
    }
    #endregion
    
  }
  #region Messages
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
  public sealed partial class CastMessage : protB::GeneratedMessageLite<CastMessage, CastMessage.Builder> {
    private CastMessage() { }
    private static readonly CastMessage defaultInstance = new CastMessage().MakeReadOnly();
    private static readonly string[] _castMessageFieldNames = new string[] { "destination_id", "namespace", "payload_binary", "payload_type", "payload_utf8", "protocol_version", "source_id" };
    private static readonly uint[] _castMessageFieldTags = new uint[] { 26, 34, 58, 40, 50, 8, 18 };
    public static CastMessage DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override CastMessage DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override CastMessage ThisMessage {
      get { return this; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public static partial class Types {
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
      public enum ProtocolVersion {
        CASTV2_1_0 = 0,
      }
      
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
      public enum PayloadType {
        STRING = 0,
        BINARY = 1,
      }
      
    }
    #endregion
    
    public const int ProtocolVersionFieldNumber = 1;
    private bool hasProtocolVersion;
    private global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.ProtocolVersion protocolVersion_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.ProtocolVersion.CASTV2_1_0;
    public bool HasProtocolVersion {
      get { return hasProtocolVersion; }
    }
    public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.ProtocolVersion ProtocolVersion {
      get { return protocolVersion_; }
    }
    
    public const int SourceIdFieldNumber = 2;
    private bool hasSourceId;
    private string sourceId_ = "";
    public bool HasSourceId {
      get { return hasSourceId; }
    }
    public string SourceId {
      get { return sourceId_; }
    }
    
    public const int DestinationIdFieldNumber = 3;
    private bool hasDestinationId;
    private string destinationId_ = "";
    public bool HasDestinationId {
      get { return hasDestinationId; }
    }
    public string DestinationId {
      get { return destinationId_; }
    }
    
    public const int NamespaceFieldNumber = 4;
    private bool hasNamespace;
    private string namespace_ = "";
    public bool HasNamespace {
      get { return hasNamespace; }
    }
    public string Namespace {
      get { return namespace_; }
    }
    
    public const int PayloadTypeFieldNumber = 5;
    private bool hasPayloadType;
    private global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.PayloadType payloadType_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.PayloadType.STRING;
    public bool HasPayloadType {
      get { return hasPayloadType; }
    }
    public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.PayloadType PayloadType {
      get { return payloadType_; }
    }
    
    public const int PayloadUtf8FieldNumber = 6;
    private bool hasPayloadUtf8;
    private string payloadUtf8_ = "";
    public bool HasPayloadUtf8 {
      get { return hasPayloadUtf8; }
    }
    public string PayloadUtf8 {
      get { return payloadUtf8_; }
    }
    
    public const int PayloadBinaryFieldNumber = 7;
    private bool hasPayloadBinary;
    private protB::ByteString payloadBinary_ = protB::ByteString.Empty;
    public bool HasPayloadBinary {
      get { return hasPayloadBinary; }
    }
    public protB::ByteString PayloadBinary {
      get { return payloadBinary_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasProtocolVersion) return false;
        if (!hasSourceId) return false;
        if (!hasDestinationId) return false;
        if (!hasNamespace) return false;
        if (!hasPayloadType) return false;
        return true;
      }
    }
    
    public override void WriteTo(protB::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _castMessageFieldNames;
      if (hasProtocolVersion) {
        output.WriteEnum(1, field_names[5], (int) ProtocolVersion, ProtocolVersion);
      }
      if (hasSourceId) {
        output.WriteString(2, field_names[6], SourceId);
      }
      if (hasDestinationId) {
        output.WriteString(3, field_names[0], DestinationId);
      }
      if (hasNamespace) {
        output.WriteString(4, field_names[1], Namespace);
      }
      if (hasPayloadType) {
        output.WriteEnum(5, field_names[3], (int) PayloadType, PayloadType);
      }
      if (hasPayloadUtf8) {
        output.WriteString(6, field_names[4], PayloadUtf8);
      }
      if (hasPayloadBinary) {
        output.WriteBytes(7, field_names[2], PayloadBinary);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasProtocolVersion) {
        size += protB::CodedOutputStream.ComputeEnumSize(1, (int) ProtocolVersion);
      }
      if (hasSourceId) {
        size += protB::CodedOutputStream.ComputeStringSize(2, SourceId);
      }
      if (hasDestinationId) {
        size += protB::CodedOutputStream.ComputeStringSize(3, DestinationId);
      }
      if (hasNamespace) {
        size += protB::CodedOutputStream.ComputeStringSize(4, Namespace);
      }
      if (hasPayloadType) {
        size += protB::CodedOutputStream.ComputeEnumSize(5, (int) PayloadType);
      }
      if (hasPayloadUtf8) {
        size += protB::CodedOutputStream.ComputeStringSize(6, PayloadUtf8);
      }
      if (hasPayloadBinary) {
        size += protB::CodedOutputStream.ComputeBytesSize(7, PayloadBinary);
      }
      memoizedSerializedSize = size;
      return size;
    }
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasProtocolVersion) hash ^= protocolVersion_.GetHashCode();
      if (hasSourceId) hash ^= sourceId_.GetHashCode();
      if (hasDestinationId) hash ^= destinationId_.GetHashCode();
      if (hasNamespace) hash ^= namespace_.GetHashCode();
      if (hasPayloadType) hash ^= payloadType_.GetHashCode();
      if (hasPayloadUtf8) hash ^= payloadUtf8_.GetHashCode();
      if (hasPayloadBinary) hash ^= payloadBinary_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      CastMessage other = obj as CastMessage;
      if (other == null) return false;
      if (hasProtocolVersion != other.hasProtocolVersion || (hasProtocolVersion && !protocolVersion_.Equals(other.protocolVersion_))) return false;
      if (hasSourceId != other.hasSourceId || (hasSourceId && !sourceId_.Equals(other.sourceId_))) return false;
      if (hasDestinationId != other.hasDestinationId || (hasDestinationId && !destinationId_.Equals(other.destinationId_))) return false;
      if (hasNamespace != other.hasNamespace || (hasNamespace && !namespace_.Equals(other.namespace_))) return false;
      if (hasPayloadType != other.hasPayloadType || (hasPayloadType && !payloadType_.Equals(other.payloadType_))) return false;
      if (hasPayloadUtf8 != other.hasPayloadUtf8 || (hasPayloadUtf8 && !payloadUtf8_.Equals(other.payloadUtf8_))) return false;
      if (hasPayloadBinary != other.hasPayloadBinary || (hasPayloadBinary && !payloadBinary_.Equals(other.payloadBinary_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("protocol_version", hasProtocolVersion, protocolVersion_, writer);
      PrintField("source_id", hasSourceId, sourceId_, writer);
      PrintField("destination_id", hasDestinationId, destinationId_, writer);
      PrintField("namespace", hasNamespace, namespace_, writer);
      PrintField("payload_type", hasPayloadType, payloadType_, writer);
      PrintField("payload_utf8", hasPayloadUtf8, payloadUtf8_, writer);
      PrintField("payload_binary", hasPayloadBinary, payloadBinary_, writer);
    }
    #endregion
    
    public static CastMessage ParseFrom(protB::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CastMessage ParseFrom(protB::ByteString data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CastMessage ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static CastMessage ParseFrom(byte[] data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static CastMessage ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CastMessage ParseFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static CastMessage ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static CastMessage ParseDelimitedFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static CastMessage ParseFrom(protB::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static CastMessage ParseFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private CastMessage MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(CastMessage prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public sealed partial class Builder : protB::GeneratedBuilderLite<CastMessage, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(CastMessage cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private CastMessage result;
      
      private CastMessage PrepareBuilder() {
        if (resultIsReadOnly) {
          CastMessage original = result;
          result = new CastMessage();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override CastMessage MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override CastMessage DefaultInstanceForType {
        get { return global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.DefaultInstance; }
      }
      
      public override CastMessage BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(protB::IMessageLite other) {
        if (other is CastMessage) {
          return MergeFrom((CastMessage) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(CastMessage other) {
        if (other == global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasProtocolVersion) {
          ProtocolVersion = other.ProtocolVersion;
        }
        if (other.HasSourceId) {
          SourceId = other.SourceId;
        }
        if (other.HasDestinationId) {
          DestinationId = other.DestinationId;
        }
        if (other.HasNamespace) {
          Namespace = other.Namespace;
        }
        if (other.HasPayloadType) {
          PayloadType = other.PayloadType;
        }
        if (other.HasPayloadUtf8) {
          PayloadUtf8 = other.PayloadUtf8;
        }
        if (other.HasPayloadBinary) {
          PayloadBinary = other.PayloadBinary;
        }
        return this;
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input) {
        return MergeFrom(input, protB::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_castMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _castMessageFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw protB::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (protB::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.protocolVersion_, out unknown)) {
                result.hasProtocolVersion = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 18: {
              result.hasSourceId = input.ReadString(ref result.sourceId_);
              break;
            }
            case 26: {
              result.hasDestinationId = input.ReadString(ref result.destinationId_);
              break;
            }
            case 34: {
              result.hasNamespace = input.ReadString(ref result.namespace_);
              break;
            }
            case 40: {
              object unknown;
              if(input.ReadEnum(ref result.payloadType_, out unknown)) {
                result.hasPayloadType = true;
              } else if(unknown is int) {
              }
              break;
            }
            case 50: {
              result.hasPayloadUtf8 = input.ReadString(ref result.payloadUtf8_);
              break;
            }
            case 58: {
              result.hasPayloadBinary = input.ReadBytes(ref result.payloadBinary_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasProtocolVersion {
       get { return result.hasProtocolVersion; }
      }
      public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.ProtocolVersion ProtocolVersion {
        get { return result.ProtocolVersion; }
        set { SetProtocolVersion(value); }
      }
      public Builder SetProtocolVersion(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.ProtocolVersion value) {
        PrepareBuilder();
        result.hasProtocolVersion = true;
        result.protocolVersion_ = value;
        return this;
      }
      public Builder ClearProtocolVersion() {
        PrepareBuilder();
        result.hasProtocolVersion = false;
        result.protocolVersion_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.ProtocolVersion.CASTV2_1_0;
        return this;
      }
      
      public bool HasSourceId {
        get { return result.hasSourceId; }
      }
      public string SourceId {
        get { return result.SourceId; }
        set { SetSourceId(value); }
      }
      public Builder SetSourceId(string value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSourceId = true;
        result.sourceId_ = value;
        return this;
      }
      public Builder ClearSourceId() {
        PrepareBuilder();
        result.hasSourceId = false;
        result.sourceId_ = "";
        return this;
      }
      
      public bool HasDestinationId {
        get { return result.hasDestinationId; }
      }
      public string DestinationId {
        get { return result.DestinationId; }
        set { SetDestinationId(value); }
      }
      public Builder SetDestinationId(string value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasDestinationId = true;
        result.destinationId_ = value;
        return this;
      }
      public Builder ClearDestinationId() {
        PrepareBuilder();
        result.hasDestinationId = false;
        result.destinationId_ = "";
        return this;
      }
      
      public bool HasNamespace {
        get { return result.hasNamespace; }
      }
      public string Namespace {
        get { return result.Namespace; }
        set { SetNamespace(value); }
      }
      public Builder SetNamespace(string value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasNamespace = true;
        result.namespace_ = value;
        return this;
      }
      public Builder ClearNamespace() {
        PrepareBuilder();
        result.hasNamespace = false;
        result.namespace_ = "";
        return this;
      }
      
      public bool HasPayloadType {
       get { return result.hasPayloadType; }
      }
      public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.PayloadType PayloadType {
        get { return result.PayloadType; }
        set { SetPayloadType(value); }
      }
      public Builder SetPayloadType(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.PayloadType value) {
        PrepareBuilder();
        result.hasPayloadType = true;
        result.payloadType_ = value;
        return this;
      }
      public Builder ClearPayloadType() {
        PrepareBuilder();
        result.hasPayloadType = false;
        result.payloadType_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.CastMessage.Types.PayloadType.STRING;
        return this;
      }
      
      public bool HasPayloadUtf8 {
        get { return result.hasPayloadUtf8; }
      }
      public string PayloadUtf8 {
        get { return result.PayloadUtf8; }
        set { SetPayloadUtf8(value); }
      }
      public Builder SetPayloadUtf8(string value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPayloadUtf8 = true;
        result.payloadUtf8_ = value;
        return this;
      }
      public Builder ClearPayloadUtf8() {
        PrepareBuilder();
        result.hasPayloadUtf8 = false;
        result.payloadUtf8_ = "";
        return this;
      }
      
      public bool HasPayloadBinary {
        get { return result.hasPayloadBinary; }
      }
      public protB::ByteString PayloadBinary {
        get { return result.PayloadBinary; }
        set { SetPayloadBinary(value); }
      }
      public Builder SetPayloadBinary(protB::ByteString value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasPayloadBinary = true;
        result.payloadBinary_ = value;
        return this;
      }
      public Builder ClearPayloadBinary() {
        PrepareBuilder();
        result.hasPayloadBinary = false;
        result.payloadBinary_ = protB::ByteString.Empty;
        return this;
      }
    }
    static CastMessage() {
      object.ReferenceEquals(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.ChromeCastAudioStream.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
  public sealed partial class AuthChallenge : protB::GeneratedMessageLite<AuthChallenge, AuthChallenge.Builder> {
    private AuthChallenge() { }
    private static readonly AuthChallenge defaultInstance = new AuthChallenge().MakeReadOnly();
    private static readonly string[] _authChallengeFieldNames = new string[] {  };
    private static readonly uint[] _authChallengeFieldTags = new uint[] {  };
    public static AuthChallenge DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AuthChallenge DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AuthChallenge ThisMessage {
      get { return this; }
    }
    
    public override bool IsInitialized {
      get {
        return true;
      }
    }
    
    public override void WriteTo(protB::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _authChallengeFieldNames;
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      memoizedSerializedSize = size;
      return size;
    }
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      AuthChallenge other = obj as AuthChallenge;
      if (other == null) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
    }
    #endregion
    
    public static AuthChallenge ParseFrom(protB::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AuthChallenge ParseFrom(protB::ByteString data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AuthChallenge ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AuthChallenge ParseFrom(byte[] data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AuthChallenge ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AuthChallenge ParseFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AuthChallenge ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AuthChallenge ParseDelimitedFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AuthChallenge ParseFrom(protB::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AuthChallenge ParseFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AuthChallenge MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AuthChallenge prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public sealed partial class Builder : protB::GeneratedBuilderLite<AuthChallenge, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AuthChallenge cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AuthChallenge result;
      
      private AuthChallenge PrepareBuilder() {
        if (resultIsReadOnly) {
          AuthChallenge original = result;
          result = new AuthChallenge();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AuthChallenge MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override AuthChallenge DefaultInstanceForType {
        get { return global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.DefaultInstance; }
      }
      
      public override AuthChallenge BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(protB::IMessageLite other) {
        if (other is AuthChallenge) {
          return MergeFrom((AuthChallenge) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AuthChallenge other) {
        if (other == global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.DefaultInstance) return this;
        PrepareBuilder();
        return this;
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input) {
        return MergeFrom(input, protB::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_authChallengeFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _authChallengeFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw protB::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (protB::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
          }
        }
        
        return this;
      }
      
    }
    static AuthChallenge() {
      object.ReferenceEquals(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.ChromeCastAudioStream.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
  public sealed partial class AuthResponse : protB::GeneratedMessageLite<AuthResponse, AuthResponse.Builder> {
    private AuthResponse() { }
    private static readonly AuthResponse defaultInstance = new AuthResponse().MakeReadOnly();
    private static readonly string[] _authResponseFieldNames = new string[] { "client_auth_certificate", "client_ca", "signature" };
    private static readonly uint[] _authResponseFieldTags = new uint[] { 18, 26, 10 };
    public static AuthResponse DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AuthResponse DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AuthResponse ThisMessage {
      get { return this; }
    }
    
    public const int SignatureFieldNumber = 1;
    private bool hasSignature;
    private protB::ByteString signature_ = protB::ByteString.Empty;
    public bool HasSignature {
      get { return hasSignature; }
    }
    public protB::ByteString Signature {
      get { return signature_; }
    }
    
    public const int ClientAuthCertificateFieldNumber = 2;
    private bool hasClientAuthCertificate;
    private protB::ByteString clientAuthCertificate_ = protB::ByteString.Empty;
    public bool HasClientAuthCertificate {
      get { return hasClientAuthCertificate; }
    }
    public protB::ByteString ClientAuthCertificate {
      get { return clientAuthCertificate_; }
    }
    
    public const int ClientCaFieldNumber = 3;
    private protBC::PopsicleList<protB::ByteString> clientCa_ = new protBC::PopsicleList<protB::ByteString>();
    public collG::IList<protB::ByteString> ClientCaList {
      get { return protBC::Lists.AsReadOnly(clientCa_); }
    }
    public int ClientCaCount {
      get { return clientCa_.Count; }
    }
    public protB::ByteString GetClientCa(int index) {
      return clientCa_[index];
    }
    
    public override bool IsInitialized {
      get {
        if (!hasSignature) return false;
        if (!hasClientAuthCertificate) return false;
        return true;
      }
    }
    
    public override void WriteTo(protB::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _authResponseFieldNames;
      if (hasSignature) {
        output.WriteBytes(1, field_names[2], Signature);
      }
      if (hasClientAuthCertificate) {
        output.WriteBytes(2, field_names[0], ClientAuthCertificate);
      }
      if (clientCa_.Count > 0) {
        output.WriteBytesArray(3, field_names[1], clientCa_);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasSignature) {
        size += protB::CodedOutputStream.ComputeBytesSize(1, Signature);
      }
      if (hasClientAuthCertificate) {
        size += protB::CodedOutputStream.ComputeBytesSize(2, ClientAuthCertificate);
      }
      {
        int dataSize = 0;
        foreach (protB::ByteString element in ClientCaList) {
          dataSize += protB::CodedOutputStream.ComputeBytesSizeNoTag(element);
        }
        size += dataSize;
        size += 1 * clientCa_.Count;
      }
      memoizedSerializedSize = size;
      return size;
    }
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasSignature) hash ^= signature_.GetHashCode();
      if (hasClientAuthCertificate) hash ^= clientAuthCertificate_.GetHashCode();
      foreach(protB::ByteString i in clientCa_)
        hash ^= i.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      AuthResponse other = obj as AuthResponse;
      if (other == null) return false;
      if (hasSignature != other.hasSignature || (hasSignature && !signature_.Equals(other.signature_))) return false;
      if (hasClientAuthCertificate != other.hasClientAuthCertificate || (hasClientAuthCertificate && !clientAuthCertificate_.Equals(other.clientAuthCertificate_))) return false;
      if(clientCa_.Count != other.clientCa_.Count) return false;
      for(int ix=0; ix < clientCa_.Count; ix++)
        if(!clientCa_[ix].Equals(other.clientCa_[ix])) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("signature", hasSignature, signature_, writer);
      PrintField("client_auth_certificate", hasClientAuthCertificate, clientAuthCertificate_, writer);
      PrintField("client_ca", clientCa_, writer);
    }
    #endregion
    
    public static AuthResponse ParseFrom(protB::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AuthResponse ParseFrom(protB::ByteString data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AuthResponse ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AuthResponse ParseFrom(byte[] data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AuthResponse ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AuthResponse ParseFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AuthResponse ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AuthResponse ParseDelimitedFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AuthResponse ParseFrom(protB::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AuthResponse ParseFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AuthResponse MakeReadOnly() {
      clientCa_.MakeReadOnly();
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AuthResponse prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public sealed partial class Builder : protB::GeneratedBuilderLite<AuthResponse, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AuthResponse cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AuthResponse result;
      
      private AuthResponse PrepareBuilder() {
        if (resultIsReadOnly) {
          AuthResponse original = result;
          result = new AuthResponse();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AuthResponse MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override AuthResponse DefaultInstanceForType {
        get { return global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.DefaultInstance; }
      }
      
      public override AuthResponse BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(protB::IMessageLite other) {
        if (other is AuthResponse) {
          return MergeFrom((AuthResponse) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AuthResponse other) {
        if (other == global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasSignature) {
          Signature = other.Signature;
        }
        if (other.HasClientAuthCertificate) {
          ClientAuthCertificate = other.ClientAuthCertificate;
        }
        if (other.clientCa_.Count != 0) {
          result.clientCa_.Add(other.clientCa_);
        }
        return this;
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input) {
        return MergeFrom(input, protB::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_authResponseFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _authResponseFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw protB::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (protB::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              result.hasSignature = input.ReadBytes(ref result.signature_);
              break;
            }
            case 18: {
              result.hasClientAuthCertificate = input.ReadBytes(ref result.clientAuthCertificate_);
              break;
            }
            case 26: {
              input.ReadBytesArray(tag, field_name, result.clientCa_);
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasSignature {
        get { return result.hasSignature; }
      }
      public protB::ByteString Signature {
        get { return result.Signature; }
        set { SetSignature(value); }
      }
      public Builder SetSignature(protB::ByteString value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasSignature = true;
        result.signature_ = value;
        return this;
      }
      public Builder ClearSignature() {
        PrepareBuilder();
        result.hasSignature = false;
        result.signature_ = protB::ByteString.Empty;
        return this;
      }
      
      public bool HasClientAuthCertificate {
        get { return result.hasClientAuthCertificate; }
      }
      public protB::ByteString ClientAuthCertificate {
        get { return result.ClientAuthCertificate; }
        set { SetClientAuthCertificate(value); }
      }
      public Builder SetClientAuthCertificate(protB::ByteString value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasClientAuthCertificate = true;
        result.clientAuthCertificate_ = value;
        return this;
      }
      public Builder ClearClientAuthCertificate() {
        PrepareBuilder();
        result.hasClientAuthCertificate = false;
        result.clientAuthCertificate_ = protB::ByteString.Empty;
        return this;
      }
      
      public protBC::IPopsicleList<protB::ByteString> ClientCaList {
        get { return PrepareBuilder().clientCa_; }
      }
      public int ClientCaCount {
        get { return result.ClientCaCount; }
      }
      public protB::ByteString GetClientCa(int index) {
        return result.GetClientCa(index);
      }
      public Builder SetClientCa(int index, protB::ByteString value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.clientCa_[index] = value;
        return this;
      }
      public Builder AddClientCa(protB::ByteString value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.clientCa_.Add(value);
        return this;
      }
      public Builder AddRangeClientCa(collG::IEnumerable<protB::ByteString> values) {
        PrepareBuilder();
        result.clientCa_.Add(values);
        return this;
      }
      public Builder ClearClientCa() {
        PrepareBuilder();
        result.clientCa_.Clear();
        return this;
      }
    }
    static AuthResponse() {
      object.ReferenceEquals(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.ChromeCastAudioStream.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
  public sealed partial class AuthError : protB::GeneratedMessageLite<AuthError, AuthError.Builder> {
    private AuthError() { }
    private static readonly AuthError defaultInstance = new AuthError().MakeReadOnly();
    private static readonly string[] _authErrorFieldNames = new string[] { "error_type" };
    private static readonly uint[] _authErrorFieldTags = new uint[] { 8 };
    public static AuthError DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override AuthError DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override AuthError ThisMessage {
      get { return this; }
    }
    
    #region Nested types
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public static partial class Types {
      [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
      [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
      public enum ErrorType {
        INTERNAL_ERROR = 0,
        NO_TLS = 1,
      }
      
    }
    #endregion
    
    public const int ErrorTypeFieldNumber = 1;
    private bool hasErrorType;
    private global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Types.ErrorType errorType_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Types.ErrorType.INTERNAL_ERROR;
    public bool HasErrorType {
      get { return hasErrorType; }
    }
    public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Types.ErrorType ErrorType {
      get { return errorType_; }
    }
    
    public override bool IsInitialized {
      get {
        if (!hasErrorType) return false;
        return true;
      }
    }
    
    public override void WriteTo(protB::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _authErrorFieldNames;
      if (hasErrorType) {
        output.WriteEnum(1, field_names[0], (int) ErrorType, ErrorType);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasErrorType) {
        size += protB::CodedOutputStream.ComputeEnumSize(1, (int) ErrorType);
      }
      memoizedSerializedSize = size;
      return size;
    }
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasErrorType) hash ^= errorType_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      AuthError other = obj as AuthError;
      if (other == null) return false;
      if (hasErrorType != other.hasErrorType || (hasErrorType && !errorType_.Equals(other.errorType_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("error_type", hasErrorType, errorType_, writer);
    }
    #endregion
    
    public static AuthError ParseFrom(protB::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AuthError ParseFrom(protB::ByteString data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AuthError ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static AuthError ParseFrom(byte[] data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static AuthError ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AuthError ParseFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static AuthError ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static AuthError ParseDelimitedFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static AuthError ParseFrom(protB::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static AuthError ParseFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private AuthError MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(AuthError prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public sealed partial class Builder : protB::GeneratedBuilderLite<AuthError, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(AuthError cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private AuthError result;
      
      private AuthError PrepareBuilder() {
        if (resultIsReadOnly) {
          AuthError original = result;
          result = new AuthError();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override AuthError MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override AuthError DefaultInstanceForType {
        get { return global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.DefaultInstance; }
      }
      
      public override AuthError BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(protB::IMessageLite other) {
        if (other is AuthError) {
          return MergeFrom((AuthError) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(AuthError other) {
        if (other == global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasErrorType) {
          ErrorType = other.ErrorType;
        }
        return this;
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input) {
        return MergeFrom(input, protB::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_authErrorFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _authErrorFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw protB::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (protB::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 8: {
              object unknown;
              if(input.ReadEnum(ref result.errorType_, out unknown)) {
                result.hasErrorType = true;
              } else if(unknown is int) {
              }
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasErrorType {
       get { return result.hasErrorType; }
      }
      public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Types.ErrorType ErrorType {
        get { return result.ErrorType; }
        set { SetErrorType(value); }
      }
      public Builder SetErrorType(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Types.ErrorType value) {
        PrepareBuilder();
        result.hasErrorType = true;
        result.errorType_ = value;
        return this;
      }
      public Builder ClearErrorType() {
        PrepareBuilder();
        result.hasErrorType = false;
        result.errorType_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Types.ErrorType.INTERNAL_ERROR;
        return this;
      }
    }
    static AuthError() {
      object.ReferenceEquals(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.ChromeCastAudioStream.Descriptor, null);
    }
  }
  
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
  [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
  public sealed partial class DeviceAuthMessage : protB::GeneratedMessageLite<DeviceAuthMessage, DeviceAuthMessage.Builder> {
    private DeviceAuthMessage() { }
    private static readonly DeviceAuthMessage defaultInstance = new DeviceAuthMessage().MakeReadOnly();
    private static readonly string[] _deviceAuthMessageFieldNames = new string[] { "challenge", "error", "response" };
    private static readonly uint[] _deviceAuthMessageFieldTags = new uint[] { 10, 26, 18 };
    public static DeviceAuthMessage DefaultInstance {
      get { return defaultInstance; }
    }
    
    public override DeviceAuthMessage DefaultInstanceForType {
      get { return DefaultInstance; }
    }
    
    protected override DeviceAuthMessage ThisMessage {
      get { return this; }
    }
    
    public const int ChallengeFieldNumber = 1;
    private bool hasChallenge;
    private global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge challenge_;
    public bool HasChallenge {
      get { return hasChallenge; }
    }
    public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge Challenge {
      get { return challenge_ ?? global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.DefaultInstance; }
    }
    
    public const int ResponseFieldNumber = 2;
    private bool hasResponse;
    private global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse response_;
    public bool HasResponse {
      get { return hasResponse; }
    }
    public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse Response {
      get { return response_ ?? global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.DefaultInstance; }
    }
    
    public const int ErrorFieldNumber = 3;
    private bool hasError;
    private global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError error_;
    public bool HasError {
      get { return hasError; }
    }
    public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError Error {
      get { return error_ ?? global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.DefaultInstance; }
    }
    
    public override bool IsInitialized {
      get {
        if (HasResponse) {
          if (!Response.IsInitialized) return false;
        }
        if (HasError) {
          if (!Error.IsInitialized) return false;
        }
        return true;
      }
    }
    
    public override void WriteTo(protB::ICodedOutputStream output) {
      CalcSerializedSize();
      string[] field_names = _deviceAuthMessageFieldNames;
      if (hasChallenge) {
        output.WriteMessage(1, field_names[0], Challenge);
      }
      if (hasResponse) {
        output.WriteMessage(2, field_names[2], Response);
      }
      if (hasError) {
        output.WriteMessage(3, field_names[1], Error);
      }
    }
    
    private int memoizedSerializedSize = -1;
    public override int SerializedSize {
      get {
        int size = memoizedSerializedSize;
        if (size != -1) return size;
        return CalcSerializedSize();
      }
    }
    
    private int CalcSerializedSize() {
      int size = memoizedSerializedSize;
      if (size != -1) return size;
      
      size = 0;
      if (hasChallenge) {
        size += protB::CodedOutputStream.ComputeMessageSize(1, Challenge);
      }
      if (hasResponse) {
        size += protB::CodedOutputStream.ComputeMessageSize(2, Response);
      }
      if (hasError) {
        size += protB::CodedOutputStream.ComputeMessageSize(3, Error);
      }
      memoizedSerializedSize = size;
      return size;
    }
    #region Lite runtime methods
    public override int GetHashCode() {
      int hash = GetType().GetHashCode();
      if (hasChallenge) hash ^= challenge_.GetHashCode();
      if (hasResponse) hash ^= response_.GetHashCode();
      if (hasError) hash ^= error_.GetHashCode();
      return hash;
    }
    
    public override bool Equals(object obj) {
      DeviceAuthMessage other = obj as DeviceAuthMessage;
      if (other == null) return false;
      if (hasChallenge != other.hasChallenge || (hasChallenge && !challenge_.Equals(other.challenge_))) return false;
      if (hasResponse != other.hasResponse || (hasResponse && !response_.Equals(other.response_))) return false;
      if (hasError != other.hasError || (hasError && !error_.Equals(other.error_))) return false;
      return true;
    }
    
    public override void PrintTo(global::System.IO.TextWriter writer) {
      PrintField("challenge", hasChallenge, challenge_, writer);
      PrintField("response", hasResponse, response_, writer);
      PrintField("error", hasError, error_, writer);
    }
    #endregion
    
    public static DeviceAuthMessage ParseFrom(protB::ByteString data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(protB::ByteString data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(byte[] data) {
      return ((Builder) CreateBuilder().MergeFrom(data)).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(byte[] data, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(data, extensionRegistry)).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(global::System.IO.Stream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    public static DeviceAuthMessage ParseDelimitedFrom(global::System.IO.Stream input) {
      return CreateBuilder().MergeDelimitedFrom(input).BuildParsed();
    }
    public static DeviceAuthMessage ParseDelimitedFrom(global::System.IO.Stream input, protB::ExtensionRegistry extensionRegistry) {
      return CreateBuilder().MergeDelimitedFrom(input, extensionRegistry).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(protB::ICodedInputStream input) {
      return ((Builder) CreateBuilder().MergeFrom(input)).BuildParsed();
    }
    public static DeviceAuthMessage ParseFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
      return ((Builder) CreateBuilder().MergeFrom(input, extensionRegistry)).BuildParsed();
    }
    private DeviceAuthMessage MakeReadOnly() {
      return this;
    }
    
    public static Builder CreateBuilder() { return new Builder(); }
    public override Builder ToBuilder() { return CreateBuilder(this); }
    public override Builder CreateBuilderForType() { return new Builder(); }
    public static Builder CreateBuilder(DeviceAuthMessage prototype) {
      return new Builder(prototype);
    }
    
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("protoc-gen-cs", "2.4.1.555")]
    public sealed partial class Builder : protB::GeneratedBuilderLite<DeviceAuthMessage, Builder> {
      protected override Builder ThisBuilder {
        get { return this; }
      }
      public Builder() {
        result = DefaultInstance;
        resultIsReadOnly = true;
      }
      internal Builder(DeviceAuthMessage cloneFrom) {
        result = cloneFrom;
        resultIsReadOnly = true;
      }
      
      private bool resultIsReadOnly;
      private DeviceAuthMessage result;
      
      private DeviceAuthMessage PrepareBuilder() {
        if (resultIsReadOnly) {
          DeviceAuthMessage original = result;
          result = new DeviceAuthMessage();
          resultIsReadOnly = false;
          MergeFrom(original);
        }
        return result;
      }
      
      public override bool IsInitialized {
        get { return result.IsInitialized; }
      }
      
      protected override DeviceAuthMessage MessageBeingBuilt {
        get { return PrepareBuilder(); }
      }
      
      public override Builder Clear() {
        result = DefaultInstance;
        resultIsReadOnly = true;
        return this;
      }
      
      public override Builder Clone() {
        if (resultIsReadOnly) {
          return new Builder(result);
        } else {
          return new Builder().MergeFrom(result);
        }
      }
      
      public override DeviceAuthMessage DefaultInstanceForType {
        get { return global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.DeviceAuthMessage.DefaultInstance; }
      }
      
      public override DeviceAuthMessage BuildPartial() {
        if (resultIsReadOnly) {
          return result;
        }
        resultIsReadOnly = true;
        return result.MakeReadOnly();
      }
      
      public override Builder MergeFrom(protB::IMessageLite other) {
        if (other is DeviceAuthMessage) {
          return MergeFrom((DeviceAuthMessage) other);
        } else {
          base.MergeFrom(other);
          return this;
        }
      }
      
      public override Builder MergeFrom(DeviceAuthMessage other) {
        if (other == global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.DeviceAuthMessage.DefaultInstance) return this;
        PrepareBuilder();
        if (other.HasChallenge) {
          MergeChallenge(other.Challenge);
        }
        if (other.HasResponse) {
          MergeResponse(other.Response);
        }
        if (other.HasError) {
          MergeError(other.Error);
        }
        return this;
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input) {
        return MergeFrom(input, protB::ExtensionRegistry.Empty);
      }
      
      public override Builder MergeFrom(protB::ICodedInputStream input, protB::ExtensionRegistry extensionRegistry) {
        PrepareBuilder();
        uint tag;
        string field_name;
        while (input.ReadTag(out tag, out field_name)) {
          if(tag == 0 && field_name != null) {
            int field_ordinal = global::System.Array.BinarySearch(_deviceAuthMessageFieldNames, field_name, global::System.StringComparer.Ordinal);
            if(field_ordinal >= 0)
              tag = _deviceAuthMessageFieldTags[field_ordinal];
            else {
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              continue;
            }
          }
          switch (tag) {
            case 0: {
              throw protB::InvalidProtocolBufferException.InvalidTag();
            }
            default: {
              if (protB::WireFormat.IsEndGroupTag(tag)) {
                return this;
              }
              ParseUnknownField(input, extensionRegistry, tag, field_name);
              break;
            }
            case 10: {
              global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.Builder subBuilder = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.CreateBuilder();
              if (result.hasChallenge) {
                subBuilder.MergeFrom(Challenge);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Challenge = subBuilder.BuildPartial();
              break;
            }
            case 18: {
              global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.Builder subBuilder = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.CreateBuilder();
              if (result.hasResponse) {
                subBuilder.MergeFrom(Response);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Response = subBuilder.BuildPartial();
              break;
            }
            case 26: {
              global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Builder subBuilder = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.CreateBuilder();
              if (result.hasError) {
                subBuilder.MergeFrom(Error);
              }
              input.ReadMessage(subBuilder, extensionRegistry);
              Error = subBuilder.BuildPartial();
              break;
            }
          }
        }
        
        return this;
      }
      
      
      public bool HasChallenge {
       get { return result.hasChallenge; }
      }
      public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge Challenge {
        get { return result.Challenge; }
        set { SetChallenge(value); }
      }
      public Builder SetChallenge(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasChallenge = true;
        result.challenge_ = value;
        return this;
      }
      public Builder SetChallenge(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.Builder builderForValue) {
        protB::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasChallenge = true;
        result.challenge_ = builderForValue.Build();
        return this;
      }
      public Builder MergeChallenge(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasChallenge &&
            result.challenge_ != global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.DefaultInstance) {
            result.challenge_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthChallenge.CreateBuilder(result.challenge_).MergeFrom(value).BuildPartial();
        } else {
          result.challenge_ = value;
        }
        result.hasChallenge = true;
        return this;
      }
      public Builder ClearChallenge() {
        PrepareBuilder();
        result.hasChallenge = false;
        result.challenge_ = null;
        return this;
      }
      
      public bool HasResponse {
       get { return result.hasResponse; }
      }
      public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse Response {
        get { return result.Response; }
        set { SetResponse(value); }
      }
      public Builder SetResponse(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasResponse = true;
        result.response_ = value;
        return this;
      }
      public Builder SetResponse(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.Builder builderForValue) {
        protB::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasResponse = true;
        result.response_ = builderForValue.Build();
        return this;
      }
      public Builder MergeResponse(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasResponse &&
            result.response_ != global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.DefaultInstance) {
            result.response_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthResponse.CreateBuilder(result.response_).MergeFrom(value).BuildPartial();
        } else {
          result.response_ = value;
        }
        result.hasResponse = true;
        return this;
      }
      public Builder ClearResponse() {
        PrepareBuilder();
        result.hasResponse = false;
        result.response_ = null;
        return this;
      }
      
      public bool HasError {
       get { return result.hasError; }
      }
      public global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError Error {
        get { return result.Error; }
        set { SetError(value); }
      }
      public Builder SetError(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        result.hasError = true;
        result.error_ = value;
        return this;
      }
      public Builder SetError(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.Builder builderForValue) {
        protB::ThrowHelper.ThrowIfNull(builderForValue, "builderForValue");
        PrepareBuilder();
        result.hasError = true;
        result.error_ = builderForValue.Build();
        return this;
      }
      public Builder MergeError(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError value) {
        protB::ThrowHelper.ThrowIfNull(value, "value");
        PrepareBuilder();
        if (result.hasError &&
            result.error_ != global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.DefaultInstance) {
            result.error_ = global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.AuthError.CreateBuilder(result.error_).MergeFrom(value).BuildPartial();
        } else {
          result.error_ = value;
        }
        result.hasError = true;
        return this;
      }
      public Builder ClearError() {
        PrepareBuilder();
        result.hasError = false;
        result.error_ = null;
        return this;
      }
    }
    static DeviceAuthMessage() {
      object.ReferenceEquals(global::ChromeCast.Desktop.AudioStreamer.ProtocolBuffer.ChromeCastAudioStream.Descriptor, null);
    }
  }
  
  #endregion
  
}

#endregion Designer generated code
